name: Deploy Stage

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Release tag to deploy (e.g., v0.0.1)"
        required: true

permissions:
  contents: read

concurrency:
  group: deploy-stage
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: stage
    timeout-minutes: 15
    env:
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
      DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
      # Optional: choose which compose file is used on the remote host.
      # Example: docker-compose.stage.with-db.yml
      DEPLOY_COMPOSE_FILE: ${{ secrets.DEPLOY_COMPOSE_FILE }}
      # Optional (recommended for private repos): allow the remote host to pull from GHCR
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
    steps:
      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "$DEPLOY_SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts || true

      - name: Deploy to stage
        env:
          IMAGE_TAG: ${{ inputs.image_tag }}
          REPO: ${{ github.repository }}
        run: |
          echo "ğŸš€ Deploying ${IMAGE_TAG} to stage"

          # SSH and deploy
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << EOF
            set -e
            cd $DEPLOY_PATH
            COMPOSE_FILE="\${DEPLOY_COMPOSE_FILE:-docker-compose.stage.yml}"

            REPO_LOWER=\$(printf '%s' "$REPO" | tr '[:upper:]' '[:lower:]')
            export BACKEND_IMAGE="ghcr.io/\${REPO_LOWER}/backend:${IMAGE_TAG}"

            if [ -n "$GHCR_TOKEN" ] && [ -n "$GHCR_USERNAME" ]; then
              echo "ğŸ” Logging in to GHCR on remote host..."
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
            fi

            # Start DB on first deploy (no-op if already running)
            if docker compose -f "\$COMPOSE_FILE" config --services 2>/dev/null | grep -qx db; then
              docker compose -f "\$COMPOSE_FILE" up -d db
            fi

            echo "ğŸ“¦ Pulling image: \${BACKEND_IMAGE}"
            BACKEND_IMAGE="\${BACKEND_IMAGE}" docker compose -f "\$COMPOSE_FILE" pull backend

            echo "ğŸš€ Updating backend (no DB restart)..."
            BACKEND_IMAGE="\${BACKEND_IMAGE}" docker compose -f "\$COMPOSE_FILE" up -d --no-deps --force-recreate backend
            
            echo "â³ Waiting for backend to be ready (ML deps may install on first run, up to 5 min)..."
            # Wait up to 6 minutes (health check start_period is 5 min)
            MAX_WAIT=360
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              if curl -sf http://localhost:8000/ready > /dev/null 2>&1; then
                echo "âœ… Backend is ready!"
                break
              fi
              echo "   Still waiting... ($ELAPSED/$MAX_WAIT seconds)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            # Final check
            if curl -sf http://localhost:8000/ready > /dev/null 2>&1; then
              echo "ğŸ§ª Smoke checks..."
              curl -sf http://localhost:8000/api/v1/health > /dev/null
              curl -sf http://localhost:8000/ > /dev/null
              echo "âœ… Stage deployment successful!"
              echo "ğŸ“Š Backend logs (last 20 lines):"
              docker compose -f "\$COMPOSE_FILE" logs --tail=20 backend
            else
              echo "âŒ Health check failed after $MAX_WAIT seconds"
              echo "ğŸ“Š Backend logs:"
              docker compose -f "\$COMPOSE_FILE" logs --tail=200 backend
              exit 1
            fi
          EOF
